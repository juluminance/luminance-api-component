import { AxiosResponse } from "axios";
import { AxiosInstance, AxiosRequestConfig } from "axios";
import { IAxiosRetryConfig } from "axios-retry";
import { ActionInputParameters } from "../../types";
import { inputs } from "./inputs";
export type HttpClient = AxiosInstance;
interface RetryConfig extends Omit<IAxiosRetryConfig, "retryDelay"> {
    /** The number of milliseconds to wait between retry attempts. */
    retryDelay?: IAxiosRetryConfig["retryDelay"] | number;
    /**
     * When true, all errors will be retried. When false, specify
     * a retryCondition function to determine when retries should occur.
     */
    retryAllErrors?: boolean;
    /** When true, double the retry delay after each attempt (e.g. 1000ms, 2000ms, 4000ms, 8000ms, etc.). */
    useExponentialBackoff?: boolean;
}
export interface ClientProps {
    /** The API's base URL (e.g. `https://api.acme.com/v2/`). */
    baseUrl?: string;
    /** The type of response to expect. Set to 'json' to automatically parse a JSON response, or 'arraybuffer' for a binary file. */
    responseType?: AxiosRequestConfig["responseType"];
    /** Headers to send for all requests (e.g. Authorization header, etc.). */
    headers?: AxiosRequestConfig["headers"];
    /** URL Search parameters to add to all requests. */
    params?: Record<string, any>;
    /** The maximum amount of time (in milliseconds) to wait for a response. Defaults to infinity. */
    timeout?: number;
    /** When enabled, log all HTTP requests and responses. */
    debug?: boolean;
    /** Configuration used to determine if and how failed HTTP requests should be retried. */
    retryConfig?: RetryConfig;
}
/**
 * Creates a reusable Axios HTTP client. See
 * https://prismatic.io/docs/custom-connectors/connections/#using-the-built-in-createclient-http-client
 */
export declare const createClient: ({ baseUrl, responseType, headers, timeout, params, debug, retryConfig, }: ClientProps) => HttpClient;
/**
 * A global error handler that examines a thrown error and yields additional
 * information if the error was produced by Spectral's HTTP client. See
 * https://prismatic.io/docs/custom-connectors/error-handling/
 * and
 * https://prismatic.io/docs/custom-connectors/connections/#using-the-built-in-createclient-http-client
 *
 * @param error A JavaScript error to handle
 * @returns An error with data, status and headers if it was an Axios error, or the error otherwise
 */
export declare const handleErrors: (error: unknown) => unknown;
type SendRawRequestValues = ActionInputParameters<typeof inputs>;
/**
 * This function allows you to build a generic "Raw Request" action
 * for a custom connector. See
 * https://prismatic.io/docs/integrations/low-code-integration-designer/raw-request-actions/#building-an-http-raw-request-action-in-your-custom-component
 *
 * @param baseUrl The base URL of the API you're integrating with
 * @param values An object comprising the HTTP request you'd like to make
 * @param authorizationHeaders Auth headers to apply to the request
 * @returns The response to the request
 */
export declare const sendRawRequest: (baseUrl: string, values: SendRawRequestValues, authorizationHeaders?: Record<string, string>) => Promise<AxiosResponse>;
export declare const buildRawRequestAction: (baseUrl: string, label?: string, description?: string) => import("../..").ActionDefinition<{
    url: {
        label: string;
        placeholder: string;
        type: "string";
        required: true;
        comments: string;
        example: string;
        clean: (value: unknown) => string;
    };
    method: {
        label: string;
        type: "string";
        required: true;
        model: {
            label: import("axios").Method;
            value: import("axios").Method;
        }[];
        comments: string;
        clean: (value: unknown) => string;
    };
    data: {
        label: string;
        placeholder: string;
        type: "string";
        required: false;
        comments: string;
        example: string;
    };
    formData: {
        label: string;
        placeholder: string;
        type: "string";
        collection: "keyvaluelist";
        required: false;
        comments: string;
        example: string;
    };
    fileData: {
        label: string;
        placeholder: string;
        type: "string";
        collection: "keyvaluelist";
        required: false;
        comments: string;
        example: string;
    };
    fileDataFileNames: {
        label: string;
        placeholder: string;
        type: "string";
        collection: "keyvaluelist";
        required: false;
        comments: string;
        clean: (values: any) => Record<string, string> | undefined;
    };
    queryParams: {
        label: string;
        placeholder: string;
        type: "string";
        collection: "keyvaluelist";
        required: false;
        comments: string;
    };
    headers: {
        label: string;
        placeholder: string;
        type: "string";
        collection: "keyvaluelist";
        required: false;
        comments: string;
        example: string;
    };
    responseType: {
        label: string;
        placeholder: string;
        type: "string";
        default: string;
        required: true;
        comments: string;
        model: {
            label: import("axios").ResponseType;
            value: import("axios").ResponseType;
        }[];
        clean: (value: unknown) => import("axios").ResponseType;
    };
    timeout: {
        label: string;
        type: "string";
        required: false;
        comments: string;
        example: string;
        clean: (value: unknown) => number;
    };
    debugRequest: {
        label: string;
        type: "boolean";
        required: false;
        comments: string;
        clean: (value: unknown) => boolean;
    };
    retryDelayMS: {
        label: string;
        placeholder: string;
        type: "string";
        required: false;
        comments: string;
        default: string;
        clean: (value: unknown) => number;
    };
    retryAllErrors: {
        label: string;
        type: "boolean";
        default: string;
        required: false;
        comments: string;
        clean: (value: unknown) => boolean;
    };
    maxRetries: {
        label: string;
        placeholder: string;
        type: "string";
        required: false;
        comments: string;
        default: string;
        clean: (value: unknown) => number;
    };
    useExponentialBackoff: {
        label: string;
        type: "boolean";
        default: string;
        required: false;
        comments: string;
        clean: (value: unknown) => boolean;
    };
    connection: {
        label: string;
        type: "connection";
        required: true;
    };
}, import("../..").ConfigVarResultCollection, boolean, {
    data: any;
}>;
export { inputs };
