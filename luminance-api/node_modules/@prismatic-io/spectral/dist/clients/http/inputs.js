"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.inputs = exports.debugRequest = exports.fileDataFileNames = exports.fileData = exports.formData = exports.retryAllErrors = exports.useExponentialBackoff = exports.retryDelayMS = exports.maxRetries = exports.queryParams = exports.headers = exports.responseType = exports.method = exports.timeout = exports.data = exports.url = void 0;
const __1 = require("../..");
const supportedMethods = [
    "DELETE",
    "GET",
    "HEAD",
    "LINK",
    "OPTIONS",
    "PATCH",
    "POST",
    "PURGE",
    "PUT",
    "UNLINK",
];
const supportedResponseTypes = ["arraybuffer", "document", "json", "text"];
exports.url = (0, __1.input)({
    label: "URL",
    placeholder: "URL to call",
    type: "string",
    required: true,
    comments: "This is the URL to call.",
    example: "/sobjects/Account",
    clean: (value) => __1.util.types.toString(value),
});
exports.data = (0, __1.input)({
    label: "Data",
    placeholder: "Data to send",
    type: "string",
    required: false,
    comments: "The HTTP body payload to send to the URL.",
    example: '{"exampleKey": "Example Data"}',
});
exports.timeout = (0, __1.input)({
    label: "Timeout",
    type: "string",
    required: false,
    comments: "The maximum time that a client will await a response to its request",
    example: "2000",
    clean: (value) => __1.util.types.toNumber(value),
});
exports.method = (0, __1.input)({
    label: "Method",
    type: "string",
    required: true,
    model: supportedMethods.map((method) => ({ label: method, value: method })),
    comments: "The HTTP method to use.",
    clean: (value) => __1.util.types.toString(value),
});
exports.responseType = (0, __1.input)({
    label: "Response Type",
    placeholder: "Response Type",
    type: "string",
    default: "json",
    required: true,
    comments: "The type of data you expect in the response. You can request json, text, or binary data.",
    model: supportedResponseTypes.map((responseType) => ({
        label: responseType,
        value: responseType,
    })),
    clean: (value) => __1.util.types.toString(value),
});
exports.headers = (0, __1.input)({
    label: "Header",
    placeholder: "Header",
    type: "string",
    collection: "keyvaluelist",
    required: false,
    comments: "A list of headers to send with the request.",
    example: "User-Agent: curl/7.64.1",
});
exports.queryParams = (0, __1.input)({
    label: "Query Parameter",
    placeholder: "Query Parameter",
    type: "string",
    collection: "keyvaluelist",
    required: false,
    comments: "A list of query parameters to send with the request. This is the portion at the end of the URL similar to ?key1=value1&key2=value2.",
});
exports.maxRetries = (0, __1.input)({
    label: "Max Retry Count",
    placeholder: "Max Retries",
    type: "string",
    required: false,
    comments: "The maximum number of retries to attempt. Specify 0 for no retries.",
    default: "0",
    clean: (value) => __1.util.types.toNumber(value),
});
exports.retryDelayMS = (0, __1.input)({
    label: "Retry Delay (ms)",
    placeholder: "Retry Delay",
    type: "string",
    required: false,
    comments: "The delay in milliseconds between retries. This is used when 'Use Exponential Backoff' is disabled.",
    default: "0",
    clean: (value) => __1.util.types.toNumber(value, 0),
});
exports.useExponentialBackoff = (0, __1.input)({
    label: "Use Exponential Backoff",
    type: "boolean",
    default: "false",
    required: false,
    comments: "Specifies whether to use a pre-defined exponential backoff strategy for retries. When enabled, 'Retry Delay (ms)' is ignored.",
    clean: (value) => __1.util.types.toBool(value),
});
exports.retryAllErrors = (0, __1.input)({
    label: "Retry On All Errors",
    type: "boolean",
    default: "false",
    required: false,
    comments: "If true, retries on all erroneous responses regardless of type. This is helpful when retrying after HTTP 429 or other 3xx or 4xx errors. Otherwise, only retries on HTTP 5xx and network errors.",
    clean: (value) => __1.util.types.toBool(value),
});
exports.formData = (0, __1.input)({
    label: "Form Data",
    placeholder: "Data to send",
    type: "string",
    collection: "keyvaluelist",
    required: false,
    comments: "The Form Data to be sent as a multipart form upload.",
    example: '[{"key": "Example Key", "value": new Buffer("Hello World")}]',
});
exports.fileData = (0, __1.input)({
    label: "File Data",
    placeholder: "Data to send",
    type: "string",
    collection: "keyvaluelist",
    required: false,
    comments: "File Data to be sent as a multipart form upload.",
    example: `[{key: "example.txt", value: "My File Contents"}]`,
});
exports.fileDataFileNames = (0, __1.input)({
    label: "File Data File Names",
    placeholder: "The file name to apply to a file",
    type: "string",
    collection: "keyvaluelist",
    required: false,
    comments: "File names to apply to the file data inputs. Keys must match the file data keys above.",
    clean: (values) => (values ? __1.util.types.keyValPairListToObject(values) : undefined),
});
exports.debugRequest = (0, __1.input)({
    label: "Debug Request",
    type: "boolean",
    required: false,
    comments: "Enabling this flag will log out the current request.",
    clean: (value) => __1.util.types.toBool(value),
});
exports.inputs = {
    url: exports.url,
    method: exports.method,
    data: exports.data,
    formData: exports.formData,
    fileData: exports.fileData,
    fileDataFileNames: exports.fileDataFileNames,
    queryParams: exports.queryParams,
    headers: exports.headers,
    responseType: exports.responseType,
    timeout: exports.timeout,
    debugRequest: exports.debugRequest,
    retryDelayMS: exports.retryDelayMS,
    retryAllErrors: exports.retryAllErrors,
    maxRetries: exports.maxRetries,
    useExponentialBackoff: exports.useExponentialBackoff,
};
