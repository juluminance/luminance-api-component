"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createPollingPerform = exports.createPerform = exports.cleanParams = void 0;
const uniq_1 = __importDefault(require("lodash/uniq"));
const context_1 = require("./context");
const cleanParams = (params, cleaners) => {
    const keys = (0, uniq_1.default)([...Object.keys(params), ...Object.keys(cleaners)]);
    return keys.reduce((result, key) => {
        const value = params[key];
        const cleanFn = cleaners[key];
        return Object.assign(Object.assign({}, result), { [key]: cleanFn ? cleanFn(value) : value });
    }, {});
};
exports.cleanParams = cleanParams;
const createPerform = (performFn, { inputCleaners, errorHandler }) => {
    return (...args) => __awaiter(void 0, void 0, void 0, function* () {
        try {
            if (args.length === 1) {
                const [params] = args;
                return yield performFn((0, exports.cleanParams)(params, inputCleaners));
            }
            if (args.length === 2) {
                const [context, params] = args;
                const actionContext = Object.assign(Object.assign({}, context), { debug: (0, context_1.createDebugContext)(context), invokeFlow: (0, context_1.createInvokeFlow)(context) });
                const result = yield performFn(actionContext, (0, exports.cleanParams)(params, inputCleaners));
                (0, context_1.logDebugResults)(actionContext);
                return result;
            }
            const [context, payload, params] = args;
            const actionContext = Object.assign(Object.assign({}, context), { debug: (0, context_1.createDebugContext)(context), invokeFlow: (0, context_1.createInvokeFlow)(context) });
            const result = yield performFn(actionContext, payload, (0, exports.cleanParams)(params, inputCleaners));
            (0, context_1.logDebugResults)(actionContext);
            return result;
        }
        catch (error) {
            throw errorHandler ? yield errorHandler(error) : error;
        }
    });
};
exports.createPerform = createPerform;
const createInvokePollAction = (context, action, { errorHandler }) => {
    return (params) => __awaiter(void 0, void 0, void 0, function* () {
        try {
            if (!action) {
                throw "Error: Attempted to invoke an action for a trigger with no pollAction defined.";
            }
            /*
             * By the time this is called, the inputs have already been cleaned
             * as part of the polling trigger setup.
             *
             * Running clean twice can have unwanted behavior depending on how users have implemented
             * their clean functions.
             */
            return yield action.perform(Object.assign(Object.assign({}, context), { debug: (0, context_1.createDebugContext)(context) }), params);
        }
        catch (error) {
            throw errorHandler ? yield errorHandler(error) : error;
        }
    });
};
const createPollingPerform = (trigger, { inputCleaners, errorHandler }) => {
    return (context, payload, params) => __awaiter(void 0, void 0, void 0, function* () {
        try {
            const { pollAction } = trigger;
            const pollingContext = {
                invokeFlow: (0, context_1.createInvokeFlow)(context),
                polling: {
                    invokeAction: createInvokePollAction(context, pollAction, {
                        errorHandler,
                    }),
                    getState: () => {
                        var _a, _b;
                        const castState = (_a = context.instanceState.__prismaticInternal) !== null && _a !== void 0 ? _a : {};
                        return (_b = castState.polling) !== null && _b !== void 0 ? _b : {};
                    },
                    setState: (newState) => {
                        var _a;
                        const castState = (_a = context.instanceState.__prismaticInternal) !== null && _a !== void 0 ? _a : {};
                        context.instanceState.__prismaticInternal = Object.assign(Object.assign({}, castState), { polling: newState });
                    },
                },
                debug: (0, context_1.createDebugContext)(context),
            };
            const triggerPerform = (0, exports.createPerform)(trigger.perform, {
                inputCleaners,
                errorHandler,
            });
            const combinedContext = Object.assign({}, context, pollingContext);
            const _a = yield triggerPerform(combinedContext, payload, params), { polledNoChanges } = _a, rest = __rest(_a, ["polledNoChanges"]);
            return Object.assign(Object.assign({}, rest), { resultType: polledNoChanges ? "polled_no_changes" : "completed" });
        }
        catch (error) {
            throw errorHandler ? yield errorHandler(error) : error;
        }
    });
};
exports.createPollingPerform = createPollingPerform;
