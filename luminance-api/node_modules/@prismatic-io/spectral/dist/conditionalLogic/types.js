"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TermOperatorPhrase = exports.BinaryOperatorPhrase = exports.BinaryOperator = exports.UnaryOperatorPhrase = exports.UnaryOperator = exports.BooleanOperatorPhrase = exports.BooleanOperator = void 0;
// GraphQL-derived enums use the same name as the constant for the value,
// but depending on how things shake out, we may be able to combine with the phrases below.
var BooleanOperator;
(function (BooleanOperator) {
    BooleanOperator["and"] = "and";
    BooleanOperator["or"] = "or";
})(BooleanOperator || (exports.BooleanOperator = BooleanOperator = {}));
exports.BooleanOperatorPhrase = Object.keys(BooleanOperator);
var UnaryOperator;
(function (UnaryOperator) {
    UnaryOperator["isTrue"] = "isTrue";
    UnaryOperator["isFalse"] = "isFalse";
    UnaryOperator["doesNotExist"] = "doesNotExist";
    UnaryOperator["exists"] = "exists";
    UnaryOperator["isEmpty"] = "isEmpty";
    UnaryOperator["isNotEmpty"] = "isNotEmpty";
})(UnaryOperator || (exports.UnaryOperator = UnaryOperator = {}));
exports.UnaryOperatorPhrase = {
    [UnaryOperator.isTrue]: "is true",
    [UnaryOperator.isFalse]: "is false",
    [UnaryOperator.doesNotExist]: "does not exist",
    [UnaryOperator.exists]: "exists",
    [UnaryOperator.isEmpty]: "is empty",
    [UnaryOperator.isNotEmpty]: "is not empty",
};
var BinaryOperator;
(function (BinaryOperator) {
    BinaryOperator["equal"] = "equal";
    BinaryOperator["notEqual"] = "notEqual";
    BinaryOperator["greaterThan"] = "greaterThan";
    BinaryOperator["greaterThanOrEqual"] = "greaterThanOrEqual";
    BinaryOperator["lessThan"] = "lessThan";
    BinaryOperator["lessThanOrEqual"] = "lessThanOrEqual";
    BinaryOperator["in"] = "in";
    BinaryOperator["notIn"] = "notIn";
    BinaryOperator["exactlyMatches"] = "exactlyMatches";
    BinaryOperator["doesNotExactlyMatch"] = "doesNotExactlyMatch";
    BinaryOperator["startsWith"] = "startsWith";
    BinaryOperator["doesNotStartWith"] = "doesNotStartWith";
    BinaryOperator["endsWith"] = "endsWith";
    BinaryOperator["doesNotEndWith"] = "doesNotEndWith";
    BinaryOperator["dateTimeAfter"] = "dateTimeAfter";
    BinaryOperator["dateTimeBefore"] = "dateTimeBefore";
    BinaryOperator["dateTimeSame"] = "dateTimeSame";
})(BinaryOperator || (exports.BinaryOperator = BinaryOperator = {}));
exports.BinaryOperatorPhrase = {
    [BinaryOperator.equal]: "equals",
    [BinaryOperator.exactlyMatches]: "exactly matches",
    [BinaryOperator.notEqual]: "does not equal",
    [BinaryOperator.doesNotExactlyMatch]: "does not exactly match",
    [BinaryOperator.greaterThan]: "is greater than",
    [BinaryOperator.greaterThanOrEqual]: "is greater than or equal to",
    [BinaryOperator.lessThan]: "is less than",
    [BinaryOperator.lessThanOrEqual]: "is less than or equal to",
    [BinaryOperator.in]: "contained in",
    [BinaryOperator.notIn]: "not contained in",
    [BinaryOperator.startsWith]: "starts the string",
    [BinaryOperator.doesNotStartWith]: "does not start the string",
    [BinaryOperator.endsWith]: "ends the string",
    [BinaryOperator.doesNotEndWith]: "does not end the string",
    [BinaryOperator.dateTimeAfter]: "is after (date/time)",
    [BinaryOperator.dateTimeBefore]: "is before (date/time)",
    [BinaryOperator.dateTimeSame]: "is the same (date/time)",
};
exports.TermOperatorPhrase = Object.assign(Object.assign({}, exports.UnaryOperatorPhrase), exports.BinaryOperatorPhrase);
