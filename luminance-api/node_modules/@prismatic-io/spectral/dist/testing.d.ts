/**
 * This module provides functions to help developers unit
 * test custom components prior to publishing them. For
 * information on unit testing, check out our docs:
 * https://prismatic.io/docs/custom-connectors/unit-testing/
 */
import { ActionPerformReturn as ServerActionPerformReturn, TriggerPayload, TriggerResult, ConnectionValue, ActionLogger, Component, DataSourceResult, DataSourceContext } from "./serverTypes";
import { ActionContext, ConnectionDefinition, ActionDefinition, TriggerDefinition, Inputs, ActionInputParameters, DataSourceDefinition, ActionPerformReturn as InvokeActionPerformReturn, TriggerResult as InvokeTriggerResult, DataSourceType, DataSourceResult as InvokeDataSourceResult, TriggerEventFunctionReturn, Flow, ConfigVarResultCollection, ComponentManifest } from "./types";
/**
 * Create a test connection to use when testing your custom component locally. See
 * https://prismatic.io/docs/custom-connectors/unit-testing/#providing-test-connection-inputs-to-an-action-test
 */
export declare const createConnection: <T extends ConnectionDefinition>({ key }: T, values: Record<string, unknown>, tokenValues?: Record<string, unknown>) => ConnectionValue;
export declare const defaultConnectionValueEnvironmentVariable = "PRISMATIC_CONNECTION_VALUE";
/**
 * Source a test connection from an environment variable for local testing. See
 * https://prismatic.io/docs/custom-connectors/unit-testing/#access-connections-for-local-testing
 */
export declare const connectionValue: (envVarKey?: string) => ConnectionValue;
/**
 * Pre-built mock of ActionLogger. Suitable for asserting logs are created as expected. See
 * https://prismatic.io/docs/custom-connectors/unit-testing/#verifying-correct-logging-in-action-tests
 * for information on testing correct logging behavior in your custom component.
 */
export declare const loggerMock: () => ActionLogger;
/**
 * Creates basic component mocks based on the CNI's component registry.
 * You may pass mock overrides in the second argument, e.g.:
 *
 * createMockContextComponents(myManifest, {
 *   actions: {
 *     myComponentName: {
 *        myComponentAction: () => Promise.resolve({ data: "my test data "}),
 *     }
 *   },
 * });
 */
export declare const createMockContextComponents: <TMockAction extends () => Promise<any>>(registry: Record<string, {
    actions: ComponentManifest["actions"];
}>, mocks?: {
    actions: Record<string, Record<string, TMockAction>>;
}) => Record<string, Record<string, TMockAction>>;
/**
 * The type of data returned by an `invoke()` function used for unit testing component actions and triggers.
 */
interface InvokeReturn<ReturnData> {
    result: ReturnData;
    loggerMock: ActionLogger;
}
/**
 * Invokes specified ActionDefinition perform function using supplied params
 * and optional context. Accepts a generic type matching ActionPerformReturn as a convenience
 * to avoid extra casting within test methods. Returns an InvokeResult containing both the
 * action result and a mock logger for asserting logging.
 */
export declare const invoke: <TInputs extends Inputs, TConfigVars extends ConfigVarResultCollection, TAllowsBranching extends boolean, TReturn extends InvokeActionPerformReturn<TAllowsBranching, unknown>>({ perform }: ActionDefinition<TInputs, TConfigVars, TAllowsBranching, TReturn>, params: ActionInputParameters<TInputs>, context?: Partial<ActionContext<TConfigVars>>) => Promise<InvokeReturn<TReturn>>;
export declare const defaultTriggerPayload: () => TriggerPayload;
/**
 * Invokes specified TriggerDefinition perform function using supplied params
 * and optional context. Accepts a generic type matching TriggerResult as a convenience
 * to avoid extra casting within test methods. Returns an InvokeResult containing both the
 * trigger result and a mock logger for asserting logging.
 */
export declare const invokeTrigger: <TInputs extends Inputs, TConfigVars extends ConfigVarResultCollection, TAllowsBranching extends boolean, TResult extends InvokeTriggerResult<TAllowsBranching, TriggerPayload>>({ perform }: TriggerDefinition<TInputs, TConfigVars, TAllowsBranching, TResult>, context?: Partial<ActionContext<TConfigVars>>, payload?: TriggerPayload, params?: ActionInputParameters<TInputs>) => Promise<InvokeReturn<TResult>>;
/**
 * Invokes specified DataSourceDefinition perform function using supplied params.
 * Accepts a generic type matching DataSourceResult as a convenience to avoid extra
 * casting within test methods. Returns a DataSourceResult.
 */
export declare const invokeDataSource: <TInputs extends Inputs, TConfigVars extends ConfigVarResultCollection, TDataSourceType extends DataSourceType>({ perform }: DataSourceDefinition<TInputs, TConfigVars, TDataSourceType>, params: ActionInputParameters<TInputs>, context?: Partial<DataSourceContext<TConfigVars>>) => Promise<InvokeDataSourceResult<TDataSourceType>>;
type TestConnectionValue = Pick<ConnectionValue, "fields" | "context" | "token">;
type TestConfigVarValues = Record<string, string | TestConnectionValue>;
type ToTestValues<TConfigVars extends ConfigVarResultCollection> = {
    [K in keyof TConfigVars]: TConfigVars[K] extends ConnectionDefinition ? TestConnectionValue : string;
};
/**
 * Invokes specified Flow of a Code Native Integration using supplied params.
 * Runs the Trigger and then the Action function and returns the result of the Action. See
 * https://prismatic.io/docs/integrations/triggers/cross-flow/#using-cross-flow-triggers-in-code-native
 */
export declare const invokeFlow: <TConfigVars extends ConfigVarResultCollection = ConfigVarResultCollection, TConfigVarValues extends TestConfigVarValues = ToTestValues<TConfigVars>>(flow: Flow, { configVars, context, payload, }?: {
    configVars?: TConfigVarValues;
    context?: Partial<ActionContext<TConfigVars>>;
    payload?: Partial<TriggerPayload>;
}) => Promise<InvokeReturn<InvokeActionPerformReturn<false, unknown>>>;
export declare class ComponentTestHarness<TComponent extends Component> {
    component: TComponent;
    constructor(component: TComponent);
    private buildParams;
    /**
     * Source a test connection from an environment variable for local testing. See
     * https://prismatic.io/docs/custom-connectors/unit-testing/#access-connections-for-local-testing
     */
    connectionValue({ key }: ConnectionDefinition): ConnectionValue;
    /**
     * Invoke a trigger by its key within a unit test. See
     * https://prismatic.io/docs/custom-connectors/unit-testing/
     */
    trigger<TConfigVars extends ConfigVarResultCollection>(key: string, payload?: TriggerPayload, params?: Record<string, unknown>, context?: Partial<ActionContext<TConfigVars>>): Promise<TriggerResult>;
    /**
     * Invoke a trigger's onInstanceDeploy function by its key within a unit test. See
     * https://prismatic.io/docs/custom-connectors/unit-testing/
     */
    triggerOnInstanceDeploy<TConfigVars extends ConfigVarResultCollection>(key: string, params?: Record<string, unknown>, context?: Partial<ActionContext<TConfigVars>>): Promise<TriggerEventFunctionReturn | void>;
    /**
     * Invoke a trigger's onInstanceDelete function by its key within a unit test. See
     * https://prismatic.io/docs/custom-connectors/unit-testing/
     */
    triggerOnInstanceDelete<TConfigVars extends ConfigVarResultCollection>(key: string, params?: Record<string, unknown>, context?: Partial<ActionContext<TConfigVars>>): Promise<TriggerEventFunctionReturn | void>;
    /**
     * Invoke an action by its key within a unit test. See
     * https://prismatic.io/docs/custom-connectors/unit-testing/
     */
    action<TConfigVars extends ConfigVarResultCollection>(key: string, params?: Record<string, unknown>, context?: Partial<ActionContext<TConfigVars>>): Promise<ServerActionPerformReturn>;
    /**
     * Invoke a data source by its key within a unit test. See
     * https://prismatic.io/docs/custom-connectors/unit-testing/
     */
    dataSource<TConfigVars extends ConfigVarResultCollection>(key: string, params?: Record<string, unknown>, context?: Partial<DataSourceContext<TConfigVars>>): Promise<DataSourceResult>;
}
/**
 * Create a testing harness to test a custom component's actions, triggers and data sources. See
 * https://prismatic.io/docs/custom-connectors/unit-testing/
 */
export declare const createHarness: <TComponent extends Component>(component: TComponent) => ComponentTestHarness<TComponent>;
declare const _default: {
    loggerMock: () => ActionLogger;
    invoke: <TInputs extends Inputs, TConfigVars extends ConfigVarResultCollection, TAllowsBranching extends boolean, TReturn extends InvokeActionPerformReturn<TAllowsBranching, unknown>>({ perform }: ActionDefinition<TInputs, TConfigVars, TAllowsBranching, TReturn>, params: ActionInputParameters<TInputs>, context?: Partial<ActionContext<TConfigVars>>) => Promise<InvokeReturn<TReturn>>;
    invokeTrigger: <TInputs extends Inputs, TConfigVars extends ConfigVarResultCollection, TAllowsBranching extends boolean, TResult extends InvokeTriggerResult<TAllowsBranching, TriggerPayload>>({ perform }: TriggerDefinition<TInputs, TConfigVars, TAllowsBranching, TResult>, context?: Partial<ActionContext<TConfigVars>>, payload?: TriggerPayload, params?: ActionInputParameters<TInputs>) => Promise<InvokeReturn<TResult>>;
    createHarness: <TComponent extends Component>(component: TComponent) => ComponentTestHarness<TComponent>;
    invokeDataSource: <TInputs extends Inputs, TConfigVars extends ConfigVarResultCollection, TDataSourceType extends DataSourceType>({ perform }: DataSourceDefinition<TInputs, TConfigVars, TDataSourceType>, params: ActionInputParameters<TInputs>, context?: Partial<DataSourceContext<TConfigVars>>) => Promise<InvokeDataSourceResult<TDataSourceType>>;
};
export default _default;
